//go:build !ignore_autogenerated

/*
 * Copyright (C) 2015 The Gravitee team (http://gravitee.io)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by controller-gen. DO NOT EDIT.

package kafka

import (
	"sigs.k8s.io/gateway-api/apis/v1"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafKaRoute) DeepCopyInto(out *KafKaRoute) {
	*out = *in
	in.CommonRouteSpec.DeepCopyInto(&out.CommonRouteSpec)
	if in.Hostname != nil {
		in, out := &in.Hostname, &out.Hostname
		*out = new(v1.Hostname)
		**out = **in
	}
	if in.BackendRefs != nil {
		in, out := &in.BackendRefs, &out.BackendRefs
		*out = make([]KafkaBackendRef, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Filters != nil {
		in, out := &in.Filters, &out.Filters
		*out = make([]KafkaRouteFilter, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[v1.AnnotationKey]v1.AnnotationValue, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafKaRoute.
func (in *KafKaRoute) DeepCopy() *KafKaRoute {
	if in == nil {
		return nil
	}
	out := new(KafKaRoute)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLFilter) DeepCopyInto(out *KafkaACLFilter) {
	*out = *in
	if in.Authorizations != nil {
		in, out := &in.Authorizations, &out.Authorizations
		*out = make([]KafkaAccessControl, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLFilter.
func (in *KafkaACLFilter) DeepCopy() *KafkaACLFilter {
	if in == nil {
		return nil
	}
	out := new(KafkaACLFilter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaAccessControl) DeepCopyInto(out *KafkaAccessControl) {
	*out = *in
	if in.Operations != nil {
		in, out := &in.Operations, &out.Operations
		*out = make([]KafkaAccessControlOperation, len(*in))
		copy(*out, *in)
	}
	if in.Match != nil {
		in, out := &in.Match, &out.Match
		*out = new(KafkaAccessControlMatch)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaAccessControl.
func (in *KafkaAccessControl) DeepCopy() *KafkaAccessControl {
	if in == nil {
		return nil
	}
	out := new(KafkaAccessControl)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaAccessControlMatch) DeepCopyInto(out *KafkaAccessControlMatch) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaAccessControlMatch.
func (in *KafkaAccessControlMatch) DeepCopy() *KafkaAccessControlMatch {
	if in == nil {
		return nil
	}
	out := new(KafkaAccessControlMatch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaBackendRef) DeepCopyInto(out *KafkaBackendRef) {
	*out = *in
	in.BackendObjectReference.DeepCopyInto(&out.BackendObjectReference)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaBackendRef.
func (in *KafkaBackendRef) DeepCopy() *KafkaBackendRef {
	if in == nil {
		return nil
	}
	out := new(KafkaBackendRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaRouteFilter) DeepCopyInto(out *KafkaRouteFilter) {
	*out = *in
	if in.ACL != nil {
		in, out := &in.ACL, &out.ACL
		*out = make([]KafkaAccessControl, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ExtensionRef != nil {
		in, out := &in.ExtensionRef, &out.ExtensionRef
		*out = new(v1.LocalObjectReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaRouteFilter.
func (in *KafkaRouteFilter) DeepCopy() *KafkaRouteFilter {
	if in == nil {
		return nil
	}
	out := new(KafkaRouteFilter)
	in.DeepCopyInto(out)
	return out
}
